/*  This file is part of vtrace.
    vtrace is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.
    vtrace is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with vtrace. If not, see <https://www.gnu.org/licenses/>.  */

#version 460 core

#define M_PI 3.1415926535
#define SQRT_2 1.4142135624
#define CAM_DIST 300.0

#define SKY_COLOR vec3(0.01, 0.01, 0.01)

#define MAX_DIST 200
#define MAX_ITER 200

#define CHUNK_WIDTH 64
#define CHUNK_SIZE (CHUNK_WIDTH * CHUNK_WIDTH * CHUNK_WIDTH)

#define REFLECT_NOISE_MAG 1.0
#define REFLECT_NOISE_POW 3.0
#define REFLECT_DAMPEN 0.5

#define VOLUMETRIC_COEFF 0.01

#define RAYS_PER_PIXEL 16

#define BLENDING 0.9

layout(local_size_x = 8, local_size_y = 8) in;
layout(binding = 0, rgba8) writeonly uniform image2D frag_color;
layout(binding = 1, rgba8) writeonly uniform image2D bright_color;
layout(binding = 2, rgba8) uniform image2D prev_frag_color;
layout(binding = 3, rgba8) uniform image2D prev_bright_color;
layout(binding = 4) buffer chunk {
    uint _chunk_data[];
};

uniform vec3 camera_loc;
uniform vec2 camera_rot;

uniform uint rand;
uniform uint blend;

uint hash(uint x) {
    x += x << 10u;
    x ^= x >>  6u;
    x += x <<  3u;
    x ^= x >> 11u;
    x += x << 15u;
    return x;
}

float randf(uint x) {
    uint h = hash(x);
    return float(h & 0x00FFFFFF) / float(0x00FFFFFF);
}

uint get_voxel(ivec3 pos) {
    if (bool(int(pos.x < 0) |
	     int(pos.y < 0) |
	     int(pos.z < 0) |
	     int(pos.x >= CHUNK_WIDTH) |
	     int(pos.y >= CHUNK_WIDTH) |
	     int(pos.z >= CHUNK_WIDTH))) return 0;
    const int index = pos.x + pos.y * CHUNK_WIDTH + pos.z * CHUNK_WIDTH * CHUNK_WIDTH;
    return _chunk_data[index];
}

void main() {
    const ivec2 image_dims = imageSize(frag_color);
    const ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    const mat3 camera_rot_mat = mat3(cos(camera_rot[0]), 0.0, sin(camera_rot[0]), 0.0, 1.0, 0.0, -sin(camera_rot[0]), 0.0, cos(camera_rot[0])) * mat3(1.0, 0.0, 0.0, 0.0, cos(camera_rot[1]), -sin(camera_rot[1]), 0.0, sin(camera_rot[1]), cos(camera_rot[1]));
    const vec3 init_ray_dir = camera_rot_mat * normalize(vec3(pixel_coords.x - image_dims.x / 2 + 0.0000001, pixel_coords.y - image_dims.y / 2 + 0.0000001, CAM_DIST));
    const vec3 init_ray_pos = camera_loc;

    const ivec3 init_map_pos = ivec3(floor(init_ray_pos));
    const ivec3 init_ray_step = ivec3(sign(init_ray_dir));

    const vec3 init_delta_dist = vec3(length(init_ray_dir)) / init_ray_dir;
    const vec3 init_side_dist = (sign(init_ray_dir) * (vec3(init_map_pos) - init_ray_pos) + sign(init_ray_dir) * 0.5 + 0.5) * abs(init_delta_dist);

    const vec3 init_hit = vec3(1.0, 1.0, 1.0);
    const uint init_iter = 0;
    const float init_reflectance = 1.0;
    const float init_hit_light = 0.0;
    vec3 accum = vec3(0.0, 0.0, 0.0);
    vec3 accum_light = vec3(0.0, 0.0, 0.0);
    for (uint ray_num = 0; ray_num < RAYS_PER_PIXEL; ++ray_num) {
	vec3 ray_dir = init_ray_dir;
	vec3 ray_pos = init_ray_pos;
	ivec3 map_pos = init_map_pos;
	ivec3 ray_step = init_ray_step;
	vec3 delta_dist = init_delta_dist;
	vec3 side_dist = init_side_dist;
	vec3 hit = init_hit;
	uint iter = init_iter;
	float reflectance = init_reflectance;
	float hit_light = init_hit_light;
	while (iter < MAX_ITER && dot(vec3(map_pos) - camera_loc, vec3(map_pos) - camera_loc) < MAX_DIST * MAX_DIST) {
	    bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
	    
	    side_dist += vec3(mask) * abs(delta_dist);
	    map_pos += ivec3(vec3(mask)) * ray_step;
	    
	    uint voxel = get_voxel(map_pos);
	    if ((voxel & 0x00000001) != 0) {
		vec3 voxel_color = vec3(
					float(voxel >> 24) / 255.0,
					float((voxel >> 16) & 0x000000FF) / 255.0,
					float((voxel >> 8) & 0x000000FF) / 255.0
					);
		vec3 border = vec3(map_pos) + (-ray_step + 1) / 2;
		vec3 dist_xyz = (border - ray_pos) * delta_dist * vec3(mask);
		float dist = dist_xyz.x + dist_xyz.y + dist_xyz.z;
		
		ray_pos += dist * ray_dir;
		ray_dir *= -2 * vec3(mask) + 1;

		uint hash = hash(gl_GlobalInvocationID.x) + hash(gl_GlobalInvocationID.y + 3) + hash(gl_GlobalInvocationID.z + 5) + ray_num + iter + rand + uint(pixel_coords.x) + uint(pixel_coords.y);
		vec3 offset = 2.0 * vec3(randf(hash),
					 randf(hash * 7),
					 randf(hash * 13)) - 1.0;
		ray_dir += sign(offset) * REFLECT_NOISE_MAG * pow(abs(offset), vec3(REFLECT_NOISE_POW));
		ray_dir = normalize(ray_dir);
		
		map_pos = ivec3(floor(ray_pos));
		ray_step = ivec3(sign(ray_dir));
		
		delta_dist = 1.0 / ray_dir;
		side_dist = (sign(ray_dir) * (vec3(map_pos) - ray_pos) + sign(ray_dir) * 0.5 + 0.5) * abs(delta_dist);
		
		float scattering = exp(-dist * VOLUMETRIC_COEFF);
		vec3 new_hit = voxel_color * scattering + SKY_COLOR * (1.0 - scattering);
		hit *= pow(new_hit, vec3(reflectance));
		if ((voxel & 0x00000002) > 0) {
		    hit_light = reflectance;
		    reflectance = 0.0;
		    break;
		}
		reflectance *= REFLECT_DAMPEN;
	    }
	    ++iter;
	}
	if (reflectance > 0)
	    hit *= pow(SKY_COLOR, vec3(reflectance));
	accum += hit;
	accum_light += hit * hit_light;
    }

    const vec4 prev_frag_color_pixel = imageLoad(prev_frag_color, pixel_coords);
    const vec4 prev_bright_color_pixel = imageLoad(prev_bright_color, pixel_coords);

    const float blend_factor = BLENDING * float(1 - blend);
    const vec4 new_frag_color_pixel = blend_factor * prev_frag_color_pixel + (1.0 - blend_factor) * vec4(accum / float(RAYS_PER_PIXEL), 1.0);
    const vec4 new_bright_color_pixel = blend_factor * prev_bright_color_pixel + (1.0 - blend_factor) * vec4(accum_light / float(RAYS_PER_PIXEL), 1.0);

    imageStore(frag_color, pixel_coords, new_frag_color_pixel);
    imageStore(bright_color, pixel_coords, new_bright_color_pixel);
    imageStore(prev_frag_color, pixel_coords, new_frag_color_pixel);
    imageStore(prev_bright_color, pixel_coords, new_bright_color_pixel);
}
