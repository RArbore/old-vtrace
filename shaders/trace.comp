/*  This file is part of vtrace.
    vtrace is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.
    vtrace is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with vtrace. If not, see <https://www.gnu.org/licenses/>.  */

#version 460 core

#define PI 3.1415926535
#define SQRT_2 1.4142135624
#define CAM_DIST 250.0

#define SKY_COLOR vec3(0.3, 0.3, 0.3)

#define MAX_ITER 200

#define CHUNK_WIDTH 4
#define CHUNK_SIZE (CHUNK_WIDTH * CHUNK_WIDTH * CHUNK_WIDTH)

#define REFLECT_PROB 0.7

#define PHONG 32.0

#define VOLUMETRIC_COEFF 0.01

#define RAYS_PER_PIXEL 2

#define BLENDING 0.95

layout(local_size_x = 8, local_size_y = 8) in;
layout(binding = 0, rgba8) writeonly uniform image2D frag_color;
layout(binding = 1, rgba8) writeonly uniform image2D bright_color;
layout(binding = 2, rgba8) uniform image2D prev_frag_color;
layout(binding = 3, rgba8) uniform image2D prev_bright_color;
layout(binding = 4) buffer chunk {
    uint _chunk_data[];
};

uniform vec3 camera_loc;
uniform vec2 camera_rot;

uniform uint rand;
uniform uint blend;

uint hash(uint x) {
    x += x << 10u;
    x ^= x >>  6u;
    x += x <<  3u;
    x ^= x >> 11u;
    x += x << 15u;
    return x;
}

float randf(uint x) {
    uint h = hash(x);
    return float(h & 0x00FFFFFF) / float(0x00FFFFFF);
}

uint get_voxel(ivec3 pos) {
    if (bool(int(pos.x < 0) |
	     int(pos.y < 0) |
	     int(pos.z < 0) |
	     int(pos.x >= CHUNK_WIDTH) |
	     int(pos.y >= CHUNK_WIDTH) |
	     int(pos.z >= CHUNK_WIDTH))) return 0;
    const int index = pos.x + pos.y * CHUNK_WIDTH + pos.z * CHUNK_WIDTH * CHUNK_WIDTH;
    return _chunk_data[index];
}

mat3 rotation_mat(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);
}

void main() {
    const ivec2 image_dims = imageSize(frag_color);
    const ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    const mat3 camera_rot_mat = mat3(cos(camera_rot[0]), 0.0, sin(camera_rot[0]), 0.0, 1.0, 0.0, -sin(camera_rot[0]), 0.0, cos(camera_rot[0])) * mat3(1.0, 0.0, 0.0, 0.0, cos(camera_rot[1]), -sin(camera_rot[1]), 0.0, sin(camera_rot[1]), cos(camera_rot[1]));
    const vec3 init_ray_dir = camera_rot_mat * normalize(vec3(pixel_coords.x - image_dims.x / 2 + 0.0000001, pixel_coords.y - image_dims.y / 2 + 0.0000001, CAM_DIST));
    const vec3 init_ray_pos = camera_loc;

    const ivec3 init_map_pos = ivec3(floor(init_ray_pos));
    const ivec3 init_ray_step = ivec3(sign(init_ray_dir));

    const vec3 init_delta_dist = vec3(length(init_ray_dir)) / init_ray_dir;
    const vec3 init_side_dist = (sign(init_ray_dir) * (vec3(init_map_pos) - init_ray_pos) + sign(init_ray_dir) * 0.5 + 0.5) * abs(init_delta_dist);

    const vec3 init_hit = vec3(1.0, 1.0, 1.0);
    const uint init_iter = 0;
    const float init_hit_light = 0.0;
    const float init_total_dist = 0.0;
    const float init_in_flight = 1.0;

    vec3 accum = vec3(0.0, 0.0, 0.0);
    vec3 accum_light = vec3(0.0, 0.0, 0.0);

    for (uint ray_num = 0; ray_num < RAYS_PER_PIXEL; ++ray_num) {
	vec3 ray_dir = init_ray_dir;
	vec3 ray_pos = init_ray_pos;
	ivec3 map_pos = init_map_pos;
	ivec3 ray_step = init_ray_step;
	vec3 delta_dist = init_delta_dist;
	vec3 side_dist = init_side_dist;
	vec3 hit = init_hit;
	uint iter = init_iter;
	float hit_light = init_hit_light;
	float total_dist = init_total_dist;
	float in_flight = init_in_flight;

	while (iter < MAX_ITER) {
	    bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
	    
	    side_dist += vec3(mask) * abs(delta_dist);
	    map_pos += ivec3(vec3(mask)) * ray_step;
	    
	    uint voxel = get_voxel(map_pos);
	    if (voxel != 0) {
		vec3 voxel_color = vec3(
					float(voxel >> 24) / 255.0,
					float((voxel >> 16) & 0x000000FF) / 255.0,
					float((voxel >> 8) & 0x000000FF) / 255.0
					);
		vec3 border = vec3(map_pos) + (-ray_step + 1) / 2;
		vec3 dist_xyz = (border - ray_pos) * delta_dist * vec3(mask);
		float dist = dist_xyz.x + dist_xyz.y + dist_xyz.z;
		total_dist += dist;
		
		ray_pos += dist * ray_dir;
		ray_dir *= -2 * vec3(mask) + 1;

		uint hash = rand * (hash(gl_GlobalInvocationID.x) + hash(gl_GlobalInvocationID.y * 3) + hash(gl_GlobalInvocationID.z * 5) + ray_num + iter + uint(pixel_coords.x) + uint(pixel_coords.y));
		float spec_z = randf(hash);
		float alpha = acos(pow(spec_z, 1.0 / (PHONG + 1.0)));
		float phi = 2.0 * PI * randf(hash * 7);
		ray_dir = rotation_mat(ray_dir, phi) * rotation_mat(cross(ray_dir, vec3(0.0, 1.0, 0.0)), alpha) * ray_dir;

		map_pos = ivec3(floor(ray_pos));
		ray_step = ivec3(sign(ray_dir));
		
		delta_dist = 1.0 / ray_dir;
		side_dist = (sign(ray_dir) * (vec3(map_pos) - ray_pos) + sign(ray_dir) * 0.5 + 0.5) * abs(delta_dist);
		
		if ((voxel & 0x00000002) > 0) {
		    vec3 new_hit = voxel_color;
		    hit *= new_hit;
		    hit_light = 1.0;
		    in_flight = 0.0;
		    break;
		}
		else if (randf(hash * 17) < REFLECT_PROB) {
		    hit *= abs(dot(ray_dir, vec3(mask)));
		}
		else {
		    vec3 new_hit = voxel_color * SKY_COLOR;
		    hit *= new_hit;
		    in_flight = 0.0;
		    break;
		}
	    }
	    ++iter;
	}
	
	hit *= SKY_COLOR * in_flight + vec3(1.0 - in_flight);

	const float scattering = exp(-total_dist * VOLUMETRIC_COEFF);
	hit = hit * scattering + SKY_COLOR * (1.0 - scattering);

	accum += hit;
	accum_light += hit * hit_light;
    }

    const vec4 prev_frag_color_pixel = imageLoad(prev_frag_color, pixel_coords);
    const vec4 prev_bright_color_pixel = imageLoad(prev_bright_color, pixel_coords);

    const float blend_factor = BLENDING * float(1 - blend);
    const vec4 new_frag_color_pixel = blend_factor * prev_frag_color_pixel + (1.0 - blend_factor) * vec4(accum / float(RAYS_PER_PIXEL), 1.0);
    const vec4 new_bright_color_pixel = blend_factor * prev_bright_color_pixel + (1.0 - blend_factor) * vec4(accum_light / float(RAYS_PER_PIXEL), 1.0);

    imageStore(frag_color, pixel_coords, new_frag_color_pixel);
    imageStore(bright_color, pixel_coords, new_bright_color_pixel);
    imageStore(prev_frag_color, pixel_coords, new_frag_color_pixel);
    imageStore(prev_bright_color, pixel_coords, new_bright_color_pixel);
}
